#include <emscripten.h>
#include <math.h>
#include <algorithm>
#include <iterator>
#include "kissfft/kiss_fftr.h"

// Corresponds to k = 1/3. See processFreqData().
float powBase = cbrt(10.0);

// MUST be
//  FFConfig.SPEC_WINDOW_SIZE / 2.
//  and FFConfig.SPEC_WINDOW_SIZE.
//  Hardcode it here for simplicity.
int hsize = 512;
int size = 1024;

// Linear resampling code (hardcoded for simplicity)
// The following code is generated by scripts/misc/linear-interpolator.py

// Begin
int numResampledBins = 144;
int loIndices[144] = {24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 31, 31, 32, 32, 33, 34, 34, 35, 36, 36, 37, 38, 38, 39, 40, 41, 41, 42, 43, 44, 45, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 63, 64, 65, 67, 68, 69, 71, 72, 73, 75, 76, 78, 79, 81, 82, 84, 85, 87, 89, 90, 92, 94, 96, 98, 100, 102, 103, 105, 108, 110, 112, 114, 116, 118, 121, 123, 125, 128, 130, 133, 135, 138, 141, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 174, 177, 180, 184, 188, 191, 195, 199, 203, 206, 210, 215, 219, 223, 227, 232, 236, 241, 245, 250, 255, 260, 265, 270, 275, 281, 286, 292, 297, 303, 309, 315, 321, 327, 334, 340, 347, 354, 360, 367, 375};
float loWeights[144] = {0.83681133, 0.30152474, 0.77318441, 0.25484044, 0.74575676, 0.24595671, 0.75612951, 0.27635378, 0.80578285, 0.34740411, 0.89608931, 0.4603838, 0.02928537, 0.61648245, 0.21035872, 0.81681158, 0.4367036, 0.06433277, 0.70929684, 0.36483739, 0.02989927, 0.71337422, 0.40802946, 0.1137946, 0.83578014, 0.57264115, 0.32203555, 0.08462105, 0.86437201, 0.66002882, 0.47009698, 0.29514349, 0.13570934, 0.99248023, 0.86833698, 0.76072365, 0.67011296, 0.59695766, 0.54169187, 0.50473221, 0.48647867, 0.48731583, 0.50761359, 0.54772794, 0.60800189, 0.68876609, 0.79033941, 0.91302968, 0.05809454, 0.22662548, 0.41740457, 0.63069202, 0.86673971, 0.12771242, 0.41422204, 0.72442515, 0.05938036, 0.4226827, 0.81050733, 0.22608195, 0.66935593, 0.13969575, 0.64002023, 0.16820379, 0.72705915, 0.31593669, 0.93469563, 0.58691383, 0.26990235, 0.98487549, 0.73521909, 0.51886048, 0.336735, 0.18973864, 0.07873079, 0.0045363, 0.968257, 0.97001248, 0.01060376, 0.09128741, 0.21245623, 0.37476563, 0.57884769, 0.82531283, 0.11571092, 0.45141591, 0.83148317, 0.25846457, 0.73244237, 0.25446818, 0.82538706, 0.44683141, 0.11834106, 0.84241984, 0.61970327, 0.45065163, 0.33651486, 0.27849313, 0.27774025, 0.33536606, 0.45243865, 0.62998717, 0.86900369, 0.17143294, 0.53828411, 0.96966626, 0.46898732, 0.03514111, 0.67171158, 0.37850674, 0.15706694, 0.0090503, 0.93635877, 0.93988114, 0.02115832, 0.18215893, 0.42396187, 0.74788393, 0.15586826, 0.64988072, 0.23094271, 0.90099306, 0.66228821, 0.51591754, 0.4638497, 0.50797791, 0.6501238, 0.89204093, 0.23626173, 0.6842858, 0.23809743, 0.89978847, 0.67192094, 0.55608645, 0.55460018, 0.66968899, 0.90349581, 0.25886152, 0.73762038, 0.34237255, 0.07525838, 0.9392479, 0.93669849, 0.07018864};
int hiIndices[144] = {23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30, 30, 31, 31, 32, 33, 33, 34, 35, 35, 36, 37, 37, 38, 39, 40, 40, 41, 42, 43, 44, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 66, 67, 68, 70, 71, 72, 74, 75, 77, 78, 80, 81, 83, 84, 86, 88, 89, 91, 93, 95, 97, 99, 101, 102, 104, 107, 109, 111, 113, 115, 117, 120, 122, 124, 127, 129, 132, 134, 137, 140, 142, 145, 148, 151, 154, 157, 160, 163, 166, 169, 173, 176, 179, 183, 187, 190, 194, 198, 202, 205, 209, 214, 218, 222, 226, 231, 235, 240, 244, 249, 254, 259, 264, 269, 274, 280, 285, 291, 296, 302, 308, 314, 320, 326, 333, 339, 346, 353, 359, 366, 374};
float hiWeights[144] = {0.16318867, 0.69847526, 0.22681559, 0.74515956, 0.25424324, 0.75404329, 0.24387049, 0.72364622, 0.19421715, 0.65259589, 0.10391069, 0.5396162, 0.97071463, 0.38351755, 0.78964128, 0.18318842, 0.5632964, 0.93566723, 0.29070316, 0.63516261, 0.97010073, 0.28662578, 0.59197054, 0.8862054, 0.16421986, 0.42735885, 0.67796445, 0.91537895, 0.13562799, 0.33997118, 0.52990302, 0.70485651, 0.86429066, 0.00751977, 0.13166302, 0.23927635, 0.32988704, 0.40304234, 0.45830813, 0.49526779, 0.51352133, 0.51268417, 0.49238641, 0.45227206, 0.39199811, 0.31123391, 0.20966059, 0.08697032, 0.94190546, 0.77337452, 0.58259543, 0.36930798, 0.13326029, 0.87228758, 0.58577796, 0.27557485, 0.94061964, 0.5773173, 0.18949267, 0.77391805, 0.33064407, 0.86030425, 0.35997977, 0.83179621, 0.27294085, 0.68406331, 0.06530437, 0.41308617, 0.73009765, 0.01512451, 0.26478091, 0.48113952, 0.663265, 0.81026136, 0.92126921, 0.9954637, 0.031743, 0.02998752, 0.98939624, 0.90871259, 0.78754377, 0.62523437, 0.42115231, 0.17468717, 0.88428908, 0.54858409, 0.16851683, 0.74153543, 0.26755763, 0.74553182, 0.17461294, 0.55316859, 0.88165894, 0.15758016, 0.38029673, 0.54934837, 0.66348514, 0.72150687, 0.72225975, 0.66463394, 0.54756135, 0.37001283, 0.13099631, 0.82856706, 0.46171589, 0.03033374, 0.53101268, 0.96485889, 0.32828842, 0.62149326, 0.84293306, 0.9909497, 0.06364123, 0.06011886, 0.97884168, 0.81784107, 0.57603813, 0.25211607, 0.84413174, 0.35011928, 0.76905729, 0.09900694, 0.33771179, 0.48408246, 0.5361503, 0.49202209, 0.3498762, 0.10795907, 0.76373827, 0.3157142, 0.76190257, 0.10021153, 0.32807906, 0.44391355, 0.44539982, 0.33031101, 0.09650419, 0.74113848, 0.26237962, 0.65762745, 0.92474162, 0.0607521, 0.06330151, 0.92981136};
// End


// FFT variables
float concatFreqData[1024] = {};
kiss_fft_cpx autocorrComplexData[512] = {};

extern "C"
EMSCRIPTEN_KEEPALIVE
void processFreqData(float *data) {

    // First perform the rescaling operation.

    // Decimal -> Decibel conversion is 20 * log10(x)
    // So we want to do 10^(x/20)
    // But remember we are using a "k" value (see ff_config.py) of 1/6.
    // So we want to do:
    //      (10^(x/20))^(1/3)
    // Which is equal to
    //      cbrt(10)^(x/20)

    // Aside:
    //  We use cube root even though our k value is 1/6. Because The k value
    //  is defined relative to Re^2 + Im^2 whereas the web audio spec gives
    //  getFloatFrequencyData values as |X[k]| ie sqrt(Re^2 + Im^2). That is,
    //  a power of a half is already accounted for. Therefore we only need
    //  to 'power down' by another factor of a third to take us to 1/6.

    for(int i = 0; i < 512; i++) {
        data[i] = pow(powBase, data[i] / 20.0);
    }

    // getFloatFrequencyData returns only the left side of the symmetric
    //  FFT spectrum. We know it's symmetric because audio data samples
    //  can only be real. But we need a 1024-length input vector for
    //  the second FFT.
    for(int i = 0; i < hsize; i++) {
        concatFreqData[i] = data[i];
    }

    // Mirror image for second half of spectrum
    for(int i = hsize + 1; i < size; i++) {
        concatFreqData[i] = data[size - i];
    }

    // Set middle value.
    //  It appears as though web FFT implementation returns one fewer
    //  piece of information than scipy (but this probably isn't the case).
    //  (it doesn't make much difference as it's such a high frequency anyway)
    concatFreqData[hsize] = data[hsize - 1];

    // Now carry out the second FFT.
    kiss_fftr_cfg cfg = kiss_fftr_alloc(1024, 0, NULL, NULL);
    kiss_fftr(cfg, concatFreqData, autocorrComplexData);
    kiss_fftr_free(cfg);

    // Note we don't read every value in data[i], that is there are
    //  FFT bins discarded by this step. We don't care about very
    //  low or very high frequencies.
    for(int i = 0; i < numResampledBins; i++) {
        //  Resample data to be on a 'linear' scale. (That is, musically
        //      linear ie ascending linearly through the MIDI notes.)
        data[i] = (
            autocorrComplexData[loIndices[i]].r * loWeights[i] +
            autocorrComplexData[hiIndices[i]].r * hiWeights[i]
        );
    }

    for(int i = 0; i < numResampledBins; i++) {
        // Copy result back to buffer exposed to javascript to view results
        // NOTE from the structuring of the FFT library all the real elements
        //  are before all the imaginary elements. We never access the
        //  imaginary part of the array (second half), as we're only
        //  interested in the real part.
        data[i] = fmax(0.0, data[i]);
    }
}

// Surma has these functions at
//  https://gist.github.com/surma/d04cd0fd896610575126d30de36d7eb6
//  https://developers.google.com/web/updates/2018/08/embind (not using embind though)

extern "C"
EMSCRIPTEN_KEEPALIVE
int mallocWrapper(int size) {
    return (int)malloc(size);
}

extern "C"
EMSCRIPTEN_KEEPALIVE
void freeWrapper(int p) {
  free((void *)p);
}